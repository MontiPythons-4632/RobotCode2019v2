// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4632.RobotCode2019v2.commands;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc4632.RobotCode2019v2.Robot;
import edu.wpi.first.wpilibj.Joystick;

/**
 *
 */
public class JoystickDrive extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
    private Joystick joystick = new Joystick(0);
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public JoystickDrive() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
 

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drive);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
        
        String work = "";

        /* get gamepad stick values */
        double forw = -1 * joystick.getY(); /* positive is forward */
        double turn = joystick.getX(); /* positive is right */
        boolean btn1 =joystick.getRawButton(1); /* is button is down, print joystick values */

        /* deadband gamepad 10% */
        if (Math.abs(forw) < 0.10) {
            forw = 0;
        }
        if (Math.abs(turn) < 0.10) {
            turn = 0;
        }
 
        //Recieve and interpret button inputs

        // fast and slow sensitivity
        double sensitivity = Robot.drive.normal; 

        if(joystick.getRawButton(2)) {
            sensitivity = Robot.drive.slow;
        }

        if(joystick.getRawButton(3)) {
            sensitivity = Robot.drive.fast;
        }

        // turnDeg
        if( !Robot.drive.isTurning() ) {
            if(joystick.getRawButton(8)) {
                Robot.drive.turnDeg(-20);
            }
            if(joystick.getRawButton(9)) {
                Robot.drive.turnDeg(20);
            }
        }

        if(joystick.getRawButton(6)){
            Robot.climberLift.raiseAll();
        }
        if(joystick.getRawButton(7)){
            Robot.climberLift.lowerAll();
        }
        if(joystick.getRawButton(8)){
            Robot.climberLift.holdAll();
        }

        if(joystick.getRawButton(10)){
            Robot.climberLift.lowerBack();
        }
        if(joystick.getRawButton(11)){
            Robot.climberLift.lowerFront();
        }

        /* drive robot */
        Robot.drive.arcade(forw * sensitivity, turn * sensitivity);

        /*
         * [2] Make sure Gamepad Forward is positive for FORWARD, and GZ is positive for
         * RIGHT
         */
        work += " GF:" + forw + " GT:" + turn;

      
        /* print to console if btn1 is held down */
        if (btn1) {
            System.out.println("debug: " + work);
        }

    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    }
}
